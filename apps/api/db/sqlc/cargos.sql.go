// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cargos.sql

package sqlc

import (
	"context"
	"time"
)

const createCargo = `-- name: CreateCargo :one
INSERT INTO cargos (
    address_sequence,
    employee_id,
    vehicle_id,
    start_date,
    deadline_date,
    price
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, address_sequence, employee_id, vehicle_id, start_date, deadline_date, price, payment_status, created_at, updated_at
`

type CreateCargoParams struct {
	AddressSequence []string  `json:"addressSequence"`
	EmployeeID      int64     `json:"employeeId"`
	VehicleID       int64     `json:"vehicleId"`
	StartDate       time.Time `json:"startDate"`
	DeadlineDate    time.Time `json:"deadlineDate"`
	Price           float64   `json:"price"`
}

func (q *Queries) CreateCargo(ctx context.Context, arg CreateCargoParams) (Cargo, error) {
	row := q.db.QueryRow(ctx, createCargo,
		arg.AddressSequence,
		arg.EmployeeID,
		arg.VehicleID,
		arg.StartDate,
		arg.DeadlineDate,
		arg.Price,
	)
	var i Cargo
	err := row.Scan(
		&i.ID,
		&i.AddressSequence,
		&i.EmployeeID,
		&i.VehicleID,
		&i.StartDate,
		&i.DeadlineDate,
		&i.Price,
		&i.PaymentStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCargo = `-- name: GetCargo :one
SELECT id, address_sequence, employee_id, vehicle_id, start_date, deadline_date, price, payment_status, created_at, updated_at FROM cargos
WHERE id = $1
`

func (q *Queries) GetCargo(ctx context.Context, id int64) (Cargo, error) {
	row := q.db.QueryRow(ctx, getCargo, id)
	var i Cargo
	err := row.Scan(
		&i.ID,
		&i.AddressSequence,
		&i.EmployeeID,
		&i.VehicleID,
		&i.StartDate,
		&i.DeadlineDate,
		&i.Price,
		&i.PaymentStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCargos = `-- name: ListCargos :many
SELECT id, address_sequence, employee_id, vehicle_id, start_date, deadline_date, price, payment_status, created_at, updated_at FROM cargos
ORDER BY created_at
LIMIT $1 OFFSET $2
`

type ListCargosParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListCargos(ctx context.Context, arg ListCargosParams) ([]Cargo, error) {
	rows, err := q.db.Query(ctx, listCargos, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Cargo{}
	for rows.Next() {
		var i Cargo
		if err := rows.Scan(
			&i.ID,
			&i.AddressSequence,
			&i.EmployeeID,
			&i.VehicleID,
			&i.StartDate,
			&i.DeadlineDate,
			&i.Price,
			&i.PaymentStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCargosDetailed = `-- name: ListCargosDetailed :many
SELECT
    c.id,
    c.address_sequence,
    c.start_date,
    c.deadline_date,
    c.price,
    c.payment_status,
    e.id as employee_id,
    e.first_name as employee_first_name,
    e.last_name as employee_last_name,
    v.id as vehicle_id,
    v.plate_number as vehicle_plate_number,
    v.make as vehicle_make,
    c.created_at,
    c.updated_at
FROM cargos c
JOIN employees e ON e.id = c.employee_id
JOIN vehicles v ON v.id = c.vehicle_id
ORDER BY c.created_at
LIMIT $1 OFFSET $2
`

type ListCargosDetailedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListCargosDetailedRow struct {
	ID                 int64     `json:"id"`
	AddressSequence    []string  `json:"addressSequence"`
	StartDate          time.Time `json:"startDate"`
	DeadlineDate       time.Time `json:"deadlineDate"`
	Price              float64   `json:"price"`
	PaymentStatus      int32     `json:"paymentStatus"`
	EmployeeID         int64     `json:"employeeId"`
	EmployeeFirstName  string    `json:"employeeFirstName"`
	EmployeeLastName   string    `json:"employeeLastName"`
	VehicleID          int64     `json:"vehicleId"`
	VehiclePlateNumber string    `json:"vehiclePlateNumber"`
	VehicleMake        *string   `json:"vehicleMake"`
	CreatedAt          time.Time `json:"createdAt"`
	UpdatedAt          time.Time `json:"updatedAt"`
}

func (q *Queries) ListCargosDetailed(ctx context.Context, arg ListCargosDetailedParams) ([]ListCargosDetailedRow, error) {
	rows, err := q.db.Query(ctx, listCargosDetailed, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCargosDetailedRow{}
	for rows.Next() {
		var i ListCargosDetailedRow
		if err := rows.Scan(
			&i.ID,
			&i.AddressSequence,
			&i.StartDate,
			&i.DeadlineDate,
			&i.Price,
			&i.PaymentStatus,
			&i.EmployeeID,
			&i.EmployeeFirstName,
			&i.EmployeeLastName,
			&i.VehicleID,
			&i.VehiclePlateNumber,
			&i.VehicleMake,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCargo = `-- name: UpdateCargo :one
UPDATE cargos
SET
    address_sequence = COALESCE($2, address_sequence),
    employee_id = COALESCE($3, employee_id),
    vehicle_id = COALESCE($4, vehicle_id),
    start_date = COALESCE($5, start_date),
    deadline_date = COALESCE($6, deadline_date),
    price = COALESCE($7, price),
    payment_status = COALESCE($8, payment_status),
    updated_at = now()
WHERE id = $1
RETURNING id, address_sequence, employee_id, vehicle_id, start_date, deadline_date, price, payment_status, created_at, updated_at
`

type UpdateCargoParams struct {
	ID              int64      `json:"id"`
	AddressSequence []string   `json:"addressSequence"`
	EmployeeID      *int64     `json:"employeeId"`
	VehicleID       *int64     `json:"vehicleId"`
	StartDate       *time.Time `json:"startDate"`
	DeadlineDate    *time.Time `json:"deadlineDate"`
	Price           *float64   `json:"price"`
	PaymentStatus   *int32     `json:"paymentStatus"`
}

func (q *Queries) UpdateCargo(ctx context.Context, arg UpdateCargoParams) (Cargo, error) {
	row := q.db.QueryRow(ctx, updateCargo,
		arg.ID,
		arg.AddressSequence,
		arg.EmployeeID,
		arg.VehicleID,
		arg.StartDate,
		arg.DeadlineDate,
		arg.Price,
		arg.PaymentStatus,
	)
	var i Cargo
	err := row.Scan(
		&i.ID,
		&i.AddressSequence,
		&i.EmployeeID,
		&i.VehicleID,
		&i.StartDate,
		&i.DeadlineDate,
		&i.Price,
		&i.PaymentStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
