// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cargos.sql

package sqlc

import (
	"context"
	"time"
)

const createCargo = `-- name: CreateCargo :one
INSERT INTO cargos (
    address_sequence,
    employee_id,
    vehicle_id,
    start_date,
    deadline_date,
    price
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, address_sequence, employee_id, vehicle_id, start_date, deadline_date, price, payment_status, created_at, updated_at
`

type CreateCargoParams struct {
	AddressSequence []string  `json:"addressSequence"`
	EmployeeID      int64     `json:"employeeId"`
	VehicleID       int64     `json:"vehicleId"`
	StartDate       time.Time `json:"startDate"`
	DeadlineDate    time.Time `json:"deadlineDate"`
	Price           float64   `json:"price"`
}

func (q *Queries) CreateCargo(ctx context.Context, arg CreateCargoParams) (Cargo, error) {
	row := q.db.QueryRow(ctx, createCargo,
		arg.AddressSequence,
		arg.EmployeeID,
		arg.VehicleID,
		arg.StartDate,
		arg.DeadlineDate,
		arg.Price,
	)
	var i Cargo
	err := row.Scan(
		&i.ID,
		&i.AddressSequence,
		&i.EmployeeID,
		&i.VehicleID,
		&i.StartDate,
		&i.DeadlineDate,
		&i.Price,
		&i.PaymentStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCargo = `-- name: GetCargo :one
SELECT id, address_sequence, employee_id, vehicle_id, start_date, deadline_date, price, payment_status, created_at, updated_at FROM cargos
WHERE id = $1
`

func (q *Queries) GetCargo(ctx context.Context, id int64) (Cargo, error) {
	row := q.db.QueryRow(ctx, getCargo, id)
	var i Cargo
	err := row.Scan(
		&i.ID,
		&i.AddressSequence,
		&i.EmployeeID,
		&i.VehicleID,
		&i.StartDate,
		&i.DeadlineDate,
		&i.Price,
		&i.PaymentStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCargos = `-- name: ListCargos :many
SELECT id, address_sequence, employee_id, vehicle_id, start_date, deadline_date, price, payment_status, created_at, updated_at FROM cargos
ORDER BY created_at
LIMIT $1 OFFSET $2
`

type ListCargosParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListCargos(ctx context.Context, arg ListCargosParams) ([]Cargo, error) {
	rows, err := q.db.Query(ctx, listCargos, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Cargo{}
	for rows.Next() {
		var i Cargo
		if err := rows.Scan(
			&i.ID,
			&i.AddressSequence,
			&i.EmployeeID,
			&i.VehicleID,
			&i.StartDate,
			&i.DeadlineDate,
			&i.Price,
			&i.PaymentStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCargo = `-- name: UpdateCargo :one
UPDATE cargos
SET
    address_sequence = $2,
    employee_id = $3,
    vehicle_id = $4,
    start_date = $5,
    deadline_date = $6,
    price = $7,
    payment_status = $8,
    updated_ad = now()
WHERE id = $1
RETURNING id, address_sequence, employee_id, vehicle_id, start_date, deadline_date, price, payment_status, created_at, updated_at
`

type UpdateCargoParams struct {
	ID              int64     `json:"id"`
	AddressSequence []string  `json:"addressSequence"`
	EmployeeID      int64     `json:"employeeId"`
	VehicleID       int64     `json:"vehicleId"`
	StartDate       time.Time `json:"startDate"`
	DeadlineDate    time.Time `json:"deadlineDate"`
	Price           float64   `json:"price"`
	PaymentStatus   int32     `json:"paymentStatus"`
}

func (q *Queries) UpdateCargo(ctx context.Context, arg UpdateCargoParams) (Cargo, error) {
	row := q.db.QueryRow(ctx, updateCargo,
		arg.ID,
		arg.AddressSequence,
		arg.EmployeeID,
		arg.VehicleID,
		arg.StartDate,
		arg.DeadlineDate,
		arg.Price,
		arg.PaymentStatus,
	)
	var i Cargo
	err := row.Scan(
		&i.ID,
		&i.AddressSequence,
		&i.EmployeeID,
		&i.VehicleID,
		&i.StartDate,
		&i.DeadlineDate,
		&i.Price,
		&i.PaymentStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
