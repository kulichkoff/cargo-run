// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cargos.sql

package sqlc

import (
	"context"
	"time"
)

const createCargo = `-- name: CreateCargo :one
INSERT INTO cargos (
    address_sequence,
    employee_id,
    vehicle_id,
    start_date,
    deadline_date,
    price,
    customer_id
) VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, address_sequence, employee_id, vehicle_id, start_date, deadline_date, price, payment_status, created_at, updated_at, customer_id
`

type CreateCargoParams struct {
	AddressSequence []string  `json:"addressSequence"`
	EmployeeID      int64     `json:"employeeId"`
	VehicleID       int64     `json:"vehicleId"`
	StartDate       time.Time `json:"startDate"`
	DeadlineDate    time.Time `json:"deadlineDate"`
	Price           float64   `json:"price"`
	CustomerID      int64     `json:"customerId"`
}

func (q *Queries) CreateCargo(ctx context.Context, arg CreateCargoParams) (Cargo, error) {
	row := q.db.QueryRow(ctx, createCargo,
		arg.AddressSequence,
		arg.EmployeeID,
		arg.VehicleID,
		arg.StartDate,
		arg.DeadlineDate,
		arg.Price,
		arg.CustomerID,
	)
	var i Cargo
	err := row.Scan(
		&i.ID,
		&i.AddressSequence,
		&i.EmployeeID,
		&i.VehicleID,
		&i.StartDate,
		&i.DeadlineDate,
		&i.Price,
		&i.PaymentStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomerID,
	)
	return i, err
}

const getCargo = `-- name: GetCargo :one
SELECT id, address_sequence, employee_id, vehicle_id, start_date, deadline_date, price, payment_status, created_at, updated_at, customer_id FROM cargos
WHERE id = $1
`

func (q *Queries) GetCargo(ctx context.Context, id int64) (Cargo, error) {
	row := q.db.QueryRow(ctx, getCargo, id)
	var i Cargo
	err := row.Scan(
		&i.ID,
		&i.AddressSequence,
		&i.EmployeeID,
		&i.VehicleID,
		&i.StartDate,
		&i.DeadlineDate,
		&i.Price,
		&i.PaymentStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomerID,
	)
	return i, err
}

const listCargos = `-- name: ListCargos :many
SELECT id, address_sequence, employee_id, vehicle_id, start_date, deadline_date, price, payment_status, created_at, updated_at, customer_id FROM cargos
ORDER BY created_at
LIMIT $1 OFFSET $2
`

type ListCargosParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListCargos(ctx context.Context, arg ListCargosParams) ([]Cargo, error) {
	rows, err := q.db.Query(ctx, listCargos, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Cargo{}
	for rows.Next() {
		var i Cargo
		if err := rows.Scan(
			&i.ID,
			&i.AddressSequence,
			&i.EmployeeID,
			&i.VehicleID,
			&i.StartDate,
			&i.DeadlineDate,
			&i.Price,
			&i.PaymentStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CustomerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCargosDetailed = `-- name: ListCargosDetailed :many
SELECT
    c.id,
    c.address_sequence,
    c.start_date,
    c.deadline_date,
    c.price,
    c.payment_status,
    e.id as employee_id,
    e.first_name as employee_first_name,
    e.last_name as employee_last_name,
    v.id as vehicle_id,
    v.plate_number as vehicle_plate_number,
    v.make as vehicle_make,
    cu.id as customer_id,
    cu.company_type as customer_company_type,
    cu.company_name as customer_company_name,
    cu.inn as customer_inn,
    cu.kpp as customer_kpp,
    cu.ogrn as customer_ogrn,
    c.created_at,
    c.updated_at
FROM cargos c
JOIN employees e ON e.id = c.employee_id
JOIN vehicles v ON v.id = c.vehicle_id
JOIN customers cu ON cu.id = c.customer_id
ORDER BY c.created_at
LIMIT $1 OFFSET $2
`

type ListCargosDetailedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListCargosDetailedRow struct {
	ID                  int64     `json:"id"`
	AddressSequence     []string  `json:"addressSequence"`
	StartDate           time.Time `json:"startDate"`
	DeadlineDate        time.Time `json:"deadlineDate"`
	Price               float64   `json:"price"`
	PaymentStatus       int32     `json:"paymentStatus"`
	EmployeeID          int64     `json:"employeeId"`
	EmployeeFirstName   string    `json:"employeeFirstName"`
	EmployeeLastName    string    `json:"employeeLastName"`
	VehicleID           int64     `json:"vehicleId"`
	VehiclePlateNumber  string    `json:"vehiclePlateNumber"`
	VehicleMake         *string   `json:"vehicleMake"`
	CustomerID          int64     `json:"customerId"`
	CustomerCompanyType string    `json:"customerCompanyType"`
	CustomerCompanyName string    `json:"customerCompanyName"`
	CustomerInn         string    `json:"customerInn"`
	CustomerKpp         string    `json:"customerKpp"`
	CustomerOgrn        string    `json:"customerOgrn"`
	CreatedAt           time.Time `json:"createdAt"`
	UpdatedAt           time.Time `json:"updatedAt"`
}

func (q *Queries) ListCargosDetailed(ctx context.Context, arg ListCargosDetailedParams) ([]ListCargosDetailedRow, error) {
	rows, err := q.db.Query(ctx, listCargosDetailed, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCargosDetailedRow{}
	for rows.Next() {
		var i ListCargosDetailedRow
		if err := rows.Scan(
			&i.ID,
			&i.AddressSequence,
			&i.StartDate,
			&i.DeadlineDate,
			&i.Price,
			&i.PaymentStatus,
			&i.EmployeeID,
			&i.EmployeeFirstName,
			&i.EmployeeLastName,
			&i.VehicleID,
			&i.VehiclePlateNumber,
			&i.VehicleMake,
			&i.CustomerID,
			&i.CustomerCompanyType,
			&i.CustomerCompanyName,
			&i.CustomerInn,
			&i.CustomerKpp,
			&i.CustomerOgrn,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCargo = `-- name: UpdateCargo :one
UPDATE cargos
SET
    address_sequence = COALESCE($2, address_sequence),
    employee_id = COALESCE($3, employee_id),
    vehicle_id = COALESCE($4, vehicle_id),
    customer_id = COALESCE($5, customer_id),
    start_date = COALESCE($6, start_date),
    deadline_date = COALESCE($7, deadline_date),
    price = COALESCE($8, price),
    payment_status = COALESCE($9, payment_status),
    updated_at = now()
WHERE id = $1
RETURNING id, address_sequence, employee_id, vehicle_id, start_date, deadline_date, price, payment_status, created_at, updated_at, customer_id
`

type UpdateCargoParams struct {
	ID              int64      `json:"id"`
	AddressSequence []string   `json:"addressSequence"`
	EmployeeID      *int64     `json:"employeeId"`
	VehicleID       *int64     `json:"vehicleId"`
	CustomerID      *int64     `json:"customerId"`
	StartDate       *time.Time `json:"startDate"`
	DeadlineDate    *time.Time `json:"deadlineDate"`
	Price           *float64   `json:"price"`
	PaymentStatus   *int32     `json:"paymentStatus"`
}

func (q *Queries) UpdateCargo(ctx context.Context, arg UpdateCargoParams) (Cargo, error) {
	row := q.db.QueryRow(ctx, updateCargo,
		arg.ID,
		arg.AddressSequence,
		arg.EmployeeID,
		arg.VehicleID,
		arg.CustomerID,
		arg.StartDate,
		arg.DeadlineDate,
		arg.Price,
		arg.PaymentStatus,
	)
	var i Cargo
	err := row.Scan(
		&i.ID,
		&i.AddressSequence,
		&i.EmployeeID,
		&i.VehicleID,
		&i.StartDate,
		&i.DeadlineDate,
		&i.Price,
		&i.PaymentStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomerID,
	)
	return i, err
}
