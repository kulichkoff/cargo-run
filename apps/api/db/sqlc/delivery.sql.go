// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: delivery.sql

package sqlc

import (
	"context"
	"time"
)

const createDelivery = `-- name: CreateDelivery :one
INSERT INTO delivery (
    pickup_address,
    delivery_address,
    pickup_time,
    delivery_deadline,
    driver_id,
    truck_id,
    customer_id
) VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, pickup_address, delivery_address, pickup_time, delivery_deadline, driver_id, truck_id, customer_id, status, created_at, updated_at
`

type CreateDeliveryParams struct {
	PickupAddress    string     `json:"pickupAddress"`
	DeliveryAddress  string     `json:"deliveryAddress"`
	PickupTime       *time.Time `json:"pickupTime"`
	DeliveryDeadline time.Time  `json:"deliveryDeadline"`
	DriverID         *int64     `json:"driverId"`
	TruckID          *int64     `json:"truckId"`
	CustomerID       *int64     `json:"customerId"`
}

func (q *Queries) CreateDelivery(ctx context.Context, arg CreateDeliveryParams) (Delivery, error) {
	row := q.db.QueryRow(ctx, createDelivery,
		arg.PickupAddress,
		arg.DeliveryAddress,
		arg.PickupTime,
		arg.DeliveryDeadline,
		arg.DriverID,
		arg.TruckID,
		arg.CustomerID,
	)
	var i Delivery
	err := row.Scan(
		&i.ID,
		&i.PickupAddress,
		&i.DeliveryAddress,
		&i.PickupTime,
		&i.DeliveryDeadline,
		&i.DriverID,
		&i.TruckID,
		&i.CustomerID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDelivery = `-- name: GetDelivery :one
SELECT id, pickup_address, delivery_address, pickup_time, delivery_deadline, driver_id, truck_id, customer_id, status, created_at, updated_at FROM delivery
WHERE id = $1
`

func (q *Queries) GetDelivery(ctx context.Context, id int64) (Delivery, error) {
	row := q.db.QueryRow(ctx, getDelivery, id)
	var i Delivery
	err := row.Scan(
		&i.ID,
		&i.PickupAddress,
		&i.DeliveryAddress,
		&i.PickupTime,
		&i.DeliveryDeadline,
		&i.DriverID,
		&i.TruckID,
		&i.CustomerID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listDeliveries = `-- name: ListDeliveries :many
SELECT id, pickup_address, delivery_address, pickup_time, delivery_deadline, driver_id, truck_id, customer_id, status, created_at, updated_at FROM delivery
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListDeliveriesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListDeliveries(ctx context.Context, arg ListDeliveriesParams) ([]Delivery, error) {
	rows, err := q.db.Query(ctx, listDeliveries, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Delivery{}
	for rows.Next() {
		var i Delivery
		if err := rows.Scan(
			&i.ID,
			&i.PickupAddress,
			&i.DeliveryAddress,
			&i.PickupTime,
			&i.DeliveryDeadline,
			&i.DriverID,
			&i.TruckID,
			&i.CustomerID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeliveriesDetailed = `-- name: ListDeliveriesDetailed :many
SELECT
    d.id,
    d.pickup_address,
    d.delivery_address,
    d.pickup_time,
    d.delivery_deadline,
    d.status,
    e.id as driver_id,
    e.first_name as driver_first_name,
    e.last_name as driver_last_name,
    v.id as truck_id,
    v.plate_number as truck_plate_number,
    v.make as truck_make,
    c.id as customer_id,
    c.company_type as customer_company_type,
    c.company_name as customer_company_name,
    c.inn as customer_inn,
    c.kpp as customer_kpp,
    c.ogrn as customer_ogrn,
    d.created_at,
    d.updated_at
FROM delivery d
LEFT JOIN driver e ON e.id = d.driver_id
LEFT JOIN truck v ON v.id = d.truck_id
LEFT JOIN customer c ON c.id = d.customer_id
ORDER BY d.created_at
LIMIT $1 OFFSET $2
`

type ListDeliveriesDetailedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListDeliveriesDetailedRow struct {
	ID                  int64      `json:"id"`
	PickupAddress       string     `json:"pickupAddress"`
	DeliveryAddress     string     `json:"deliveryAddress"`
	PickupTime          *time.Time `json:"pickupTime"`
	DeliveryDeadline    time.Time  `json:"deliveryDeadline"`
	Status              string     `json:"status"`
	DriverID            *int64     `json:"driverId"`
	DriverFirstName     *string    `json:"driverFirstName"`
	DriverLastName      *string    `json:"driverLastName"`
	TruckID             *int64     `json:"truckId"`
	TruckPlateNumber    *string    `json:"truckPlateNumber"`
	TruckMake           *string    `json:"truckMake"`
	CustomerID          *int64     `json:"customerId"`
	CustomerCompanyType *string    `json:"customerCompanyType"`
	CustomerCompanyName *string    `json:"customerCompanyName"`
	CustomerInn         *string    `json:"customerInn"`
	CustomerKpp         *string    `json:"customerKpp"`
	CustomerOgrn        *string    `json:"customerOgrn"`
	CreatedAt           time.Time  `json:"createdAt"`
	UpdatedAt           time.Time  `json:"updatedAt"`
}

func (q *Queries) ListDeliveriesDetailed(ctx context.Context, arg ListDeliveriesDetailedParams) ([]ListDeliveriesDetailedRow, error) {
	rows, err := q.db.Query(ctx, listDeliveriesDetailed, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDeliveriesDetailedRow{}
	for rows.Next() {
		var i ListDeliveriesDetailedRow
		if err := rows.Scan(
			&i.ID,
			&i.PickupAddress,
			&i.DeliveryAddress,
			&i.PickupTime,
			&i.DeliveryDeadline,
			&i.Status,
			&i.DriverID,
			&i.DriverFirstName,
			&i.DriverLastName,
			&i.TruckID,
			&i.TruckPlateNumber,
			&i.TruckMake,
			&i.CustomerID,
			&i.CustomerCompanyType,
			&i.CustomerCompanyName,
			&i.CustomerInn,
			&i.CustomerKpp,
			&i.CustomerOgrn,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDelivery = `-- name: UpdateDelivery :one
UPDATE delivery
SET
    pickup_address = COALESCE($2, pickup_address),
    delivery_address = COALESCE($3, delivery_address),
    pickup_time = COALESCE($4, pickup_time),
    delivery_deadline = COALESCE($5, delivery_deadline),
    status = COALESCE($6, status),
    driver_id = COALESCE($7, driver_id),
    truck_id = COALESCE($8, truck_id),
    customer_id = COALESCE($9, customer_id),
    updated_at = now()
WHERE id = $1
RETURNING id, pickup_address, delivery_address, pickup_time, delivery_deadline, driver_id, truck_id, customer_id, status, created_at, updated_at
`

type UpdateDeliveryParams struct {
	ID               int64      `json:"id"`
	PickupAddress    *string    `json:"pickupAddress"`
	DeliveryAddress  *string    `json:"deliveryAddress"`
	PickupTime       *time.Time `json:"pickupTime"`
	DeliveryDeadline *time.Time `json:"deliveryDeadline"`
	Status           *string    `json:"status"`
	DriverID         *int64     `json:"driverId"`
	TruckID          *int64     `json:"truckId"`
	CustomerID       *int64     `json:"customerId"`
}

func (q *Queries) UpdateDelivery(ctx context.Context, arg UpdateDeliveryParams) (Delivery, error) {
	row := q.db.QueryRow(ctx, updateDelivery,
		arg.ID,
		arg.PickupAddress,
		arg.DeliveryAddress,
		arg.PickupTime,
		arg.DeliveryDeadline,
		arg.Status,
		arg.DriverID,
		arg.TruckID,
		arg.CustomerID,
	)
	var i Delivery
	err := row.Scan(
		&i.ID,
		&i.PickupAddress,
		&i.DeliveryAddress,
		&i.PickupTime,
		&i.DeliveryDeadline,
		&i.DriverID,
		&i.TruckID,
		&i.CustomerID,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
