// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: vehicles.sql

package sqlc

import (
	"context"
)

const createVehicle = `-- name: CreateVehicle :one
INSERT INTO vehicles
(plate_number, make, model, vin, manufacture_year)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, plate_number, make, model, vin, manufacture_year, created_at, updated_at
`

type CreateVehicleParams struct {
	PlateNumber     string  `json:"plateNumber"`
	Make            *string `json:"make"`
	Model           *string `json:"model"`
	Vin             *string `json:"vin"`
	ManufactureYear *int32  `json:"manufactureYear"`
}

// Inserts a new vehicle and returns the created result
func (q *Queries) CreateVehicle(ctx context.Context, arg CreateVehicleParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, createVehicle,
		arg.PlateNumber,
		arg.Make,
		arg.Model,
		arg.Vin,
		arg.ManufactureYear,
	)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.PlateNumber,
		&i.Make,
		&i.Model,
		&i.Vin,
		&i.ManufactureYear,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVehicle = `-- name: GetVehicle :one
SELECT id, plate_number, make, model, vin, manufacture_year, created_at, updated_at FROM vehicles
WHERE id = $1
`

// Retrieves a single vehicle by ID
func (q *Queries) GetVehicle(ctx context.Context, id int64) (Vehicle, error) {
	row := q.db.QueryRow(ctx, getVehicle, id)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.PlateNumber,
		&i.Make,
		&i.Model,
		&i.Vin,
		&i.ManufactureYear,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listVehicles = `-- name: ListVehicles :many
SELECT id, plate_number, make, model, vin, manufacture_year, created_at, updated_at FROM vehicles
ORDER BY plate_number
LIMIT $1 OFFSET $2
`

type ListVehiclesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Retrieves all vehicles ordered by plate number with pagination
func (q *Queries) ListVehicles(ctx context.Context, arg ListVehiclesParams) ([]Vehicle, error) {
	rows, err := q.db.Query(ctx, listVehicles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Vehicle{}
	for rows.Next() {
		var i Vehicle
		if err := rows.Scan(
			&i.ID,
			&i.PlateNumber,
			&i.Make,
			&i.Model,
			&i.Vin,
			&i.ManufactureYear,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVehicle = `-- name: UpdateVehicle :one
UPDATE vehicles
SET plate_number = $2, make = $3, model = $4,
    vin = $5, manufacture_year = $6,
    updated_at = now()
WHERE id = $1
RETURNING id, plate_number, make, model, vin, manufacture_year, created_at, updated_at
`

type UpdateVehicleParams struct {
	ID              int64   `json:"id"`
	PlateNumber     string  `json:"plateNumber"`
	Make            *string `json:"make"`
	Model           *string `json:"model"`
	Vin             *string `json:"vin"`
	ManufactureYear *int32  `json:"manufactureYear"`
}

// Updates a vehicle's information and returns the updated record
func (q *Queries) UpdateVehicle(ctx context.Context, arg UpdateVehicleParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, updateVehicle,
		arg.ID,
		arg.PlateNumber,
		arg.Make,
		arg.Model,
		arg.Vin,
		arg.ManufactureYear,
	)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.PlateNumber,
		&i.Make,
		&i.Model,
		&i.Vin,
		&i.ManufactureYear,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
